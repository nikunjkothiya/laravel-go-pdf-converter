package pdf

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/signintech/gopdf"
)

// Builder provides a fluent interface for creating PDF documents
type Builder struct {
	pdf       *gopdf.GoPdf
	options   Options
	currentY  float64
	pageNum   int
	fontLoaded bool
	
	onProgress func(int)
}

// SetProgressCallback sets the callback for progress reporting
func (b *Builder) SetProgressCallback(callback func(int)) {
	b.onProgress = callback
}

// NewBuilder creates a new PDF builder with the given options
func NewBuilder(opts Options) (*Builder, error) {
	pdf := &gopdf.GoPdf{}
	pdf.Start(gopdf.Config{PageSize: *opts.GetPageRect()})

	b := &Builder{
		pdf:      pdf,
		options:  opts,
		currentY: opts.Margin,
		pageNum:  0,
	}

	// Load default font
	if err := b.loadFont(); err != nil {
		return nil, err
	}

	return b, nil
}

// loadFont loads the specified font or falls back to built-in
func (b *Builder) loadFont() error {
	// 1. Try custom font if specified
	if b.options.CustomFontPath != "" {
		if _, err := os.Stat(b.options.CustomFontPath); err == nil {
			if err := b.pdf.AddTTFFont("default", b.options.CustomFontPath); err == nil {
				b.fontLoaded = true
				return b.pdf.SetFont("default", "", b.options.FontSize)
			}
		}
	}

	// 2. Try to use system fonts first
	fontPaths := []string{
		"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
		"/usr/share/fonts/TTF/DejaVuSans.ttf",
		"/System/Library/Fonts/Helvetica.ttc",
		"C:\\Windows\\Fonts\\arial.ttf",
	}

	for _, fontPath := range fontPaths {
		if _, err := os.Stat(fontPath); err == nil {
			if err := b.pdf.AddTTFFont("default", fontPath); err == nil {
				b.fontLoaded = true
				return b.pdf.SetFont("default", "", b.options.FontSize)
			}
		}
	}

	// 3. Fall back to built-in font (limited Unicode support)
	return b.embedMinimalFont()
}

// embedMinimalFont embeds a minimal font for basic operation
func (b *Builder) embedMinimalFont() error {
	// Use the TTF font embedded in the binary or from a known location
	// For now, we'll try common locations
	homeDir, _ := os.UserHomeDir()
	additionalPaths := []string{
		filepath.Join(homeDir, ".fonts", "DejaVuSans.ttf"),
		"/usr/local/share/fonts/truetype/dejavu/DejaVuSans.ttf",
	}

	for _, fontPath := range additionalPaths {
		if _, err := os.Stat(fontPath); err == nil {
			if err := b.pdf.AddTTFFont("default", fontPath); err == nil {
				b.fontLoaded = true
				return b.pdf.SetFont("default", "", b.options.FontSize)
			}
		}
	}

	return nil // Proceed without font, will use basic rendering
}

// AddPage adds a new page to the document
func (b *Builder) AddPage() {
	b.pdf.AddPage()
	b.currentY = b.options.Margin
	b.pageNum++
	
	// Draw watermark first (behind content)
	b.drawWatermark()
	
	// Draw global header and footer
	b.drawHeader()
	b.drawFooter()
	
	// Reset Y to below header
	b.currentY = b.options.Margin + 20
}

func (b *Builder) drawHeader() {
	style := DefaultStyle()
	style.FontSize = 8
	style.TextColor = ColorGray
	
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	b.SetTextColor(style.TextColor)
	
	// Simplified Header: Always Center
	if b.options.HeaderText != "" {
		b.drawTextWithPlaceholders(b.options.HeaderText, AlignCenter)
	} else {
		// Default header if none provided
		b.drawTextWithPlaceholders("Generated Report", AlignCenter)
	}
}

func (b *Builder) drawFooter() {
	pageHeight := b.options.PageSize.Height
	if b.options.Orientation == Landscape {
		pageHeight = b.options.PageSize.Width
	}
	
	style := DefaultStyle()
	style.FontSize = 8
	style.TextColor = ColorGray
	
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	b.SetTextColor(style.TextColor)
	
	footerY := pageHeight - b.options.Margin + 5

	// Simplified Footer:
	// Left: Custom Text (or default)
	// Right: Page Info (Fixed)

	// Left Section
	text := b.options.FooterText
	if text == "" {
		text = "Generated by GoPdfConverter" // Default
	}
	
	b.pdf.SetX(b.options.Margin)
	b.pdf.SetY(footerY)
	b.drawTextWithPlaceholders(text, AlignLeft)

	// Right Section: Page Info (Fixed)
	// "Page X of Y"
	pageInfo := "Page {{page}} of {{total}}"
	b.pdf.SetY(footerY)
	b.drawTextWithPlaceholders(pageInfo, AlignRight)
}

func (b *Builder) drawTextWithPlaceholders(text string, align int) {
	// Paging placeholders
	text = strings.ReplaceAll(text, "{{page}}", fmt.Sprintf("%d", b.pageNum))
	
	// Total pages is tricky because we don't know it yet.
	// For "Page X of Y", we usually use a template approach or write it at the end.
	// Gopdf has a specific way to handle total pages using FillInPlaceHoldText
	
	hasTotal := strings.Contains(text, "{{total}}")
	b.drawAligned(text, align, hasTotal)
}

func (b *Builder) drawAligned(text string, align int, hasPlaceholder bool) {
	pageWidth := b.options.PageSize.Width
	if b.options.Orientation == Landscape {
		pageWidth = b.options.PageSize.Height
	}
	contentWidth := pageWidth - (b.options.Margin * 2)

	// Measure text width
	// Note: If hasPlaceholder, we might need to estimate
	textWidth := b.MeasureTextWidth(text)
	if hasPlaceholder {
		textWidth += 20 // Estimate for number
	}

	var x float64
	switch align {
	case AlignLeft:
		x = b.options.Margin
	case AlignCenter:
		x = b.options.Margin + (contentWidth-textWidth)/2
	case AlignRight:
		x = b.options.Margin + contentWidth - textWidth
	}

	// Use explicit Text drawing to ensure baseline alignment matches
	// PlaceHolderText behavior and avoids Cell vertical centering issues
	b.pdf.SetX(x)
	
	if hasPlaceholder {
		parts := strings.Split(text, "{{total}}")
		
		// 1. Draw Prefix (e.g. "Page 1 of ")
		if len(parts) > 0 && parts[0] != "" {
			b.pdf.Text(parts[0])
			// Advance X manually
			w, _ := b.pdf.MeasureTextWidth(parts[0])
			x += w
			b.pdf.SetX(x)
		}
		
		// 2. Draw Placeholder
		currentY := b.pdf.GetY()
		b.pdf.PlaceHolderText("total", 20)
		
		x += 20 // Advance X for placeholder width
		b.pdf.SetX(x)
		
		// Restore Y just in case PlaceHolderText moved it (it shouldn't)
		b.pdf.SetY(currentY)
		
		// 3. Draw Suffix
		if len(parts) > 1 && parts[1] != "" {
			b.pdf.Text(parts[1])
		}
	} else {
		b.pdf.Text(text)
	}
}

// SetFont sets the current font
func (b *Builder) SetFont(family string, style string, size float64) error {
	if !b.fontLoaded {
		return nil
	}
	return b.pdf.SetFont("default", style, size)
}

// SetTextColor sets the text color
func (b *Builder) SetTextColor(c Color) {
	b.pdf.SetTextColor(c.R, c.G, c.B)
}

// SetFillColor sets the fill color
func (b *Builder) SetFillColor(c Color) {
	b.pdf.SetFillColor(c.R, c.G, c.B)
}

// SetStrokeColor sets the stroke/border color
func (b *Builder) SetStrokeColor(c Color) {
	b.pdf.SetStrokeColor(c.R, c.G, c.B)
}

// GetX returns current X position
func (b *Builder) GetX() float64 {
	return b.pdf.GetX()
}

// GetY returns current Y position
func (b *Builder) GetY() float64 {
	return b.currentY
}

// SetXY sets the current position
func (b *Builder) SetXY(x, y float64) {
	b.pdf.SetX(x)
	b.pdf.SetY(y)
	b.currentY = y
}

// drawWatermark draws a watermark on the current page
func (b *Builder) drawWatermark() {
	if b.options.WatermarkText == "" && b.options.WatermarkImage == "" {
		return
	}

	// Save current state
	// b.pdf.SetAlpha(b.options.WatermarkAlpha, "Normal")
	// defer b.pdf.SetAlpha(1.0, "Normal")

	pageW := b.options.PageSize.Width
	pageH := b.options.PageSize.Height
	if b.options.Orientation == Landscape {
		pageW, pageH = pageH, pageW
	}

	// Draw Image Watermark
	if b.options.WatermarkImage != "" {
		if _, err := os.Stat(b.options.WatermarkImage); err == nil {
			// Center image
			imgW := 200.0 // Default width
			imgH := 200.0 // Default height
			x := (pageW - imgW) / 2
			y := (pageH - imgH) / 2
			b.pdf.Image(b.options.WatermarkImage, x, y, &gopdf.Rect{W: imgW, H: imgH})
		}
	}

	// Draw Text Watermark
	if b.options.WatermarkText != "" {
		b.pdf.SetTextColor(200, 200, 200) // Light gray
		
		// Calculate font size based on page width
		fontSize := pageW / 10
		b.pdf.SetFont("default", "", fontSize)
		
		textWidth := b.MeasureTextWidth(b.options.WatermarkText)
		x := (pageW - textWidth) / 2
		y := pageH / 2

		// Rotate text 45 degrees
		b.pdf.Rotate(45, x+textWidth/2, y)
		b.pdf.SetX(x)
		b.pdf.SetY(y)
		b.pdf.Text(b.options.WatermarkText)
		b.pdf.RotateReset()
	}
}

// Cell draws a cell with text, supporting text wrapping for long content
func (b *Builder) Cell(w, h float64, text string, style Style) error {
	x := b.pdf.GetX()
	y := b.currentY

	// Draw background if specified
	if style.HasBackground {
		b.SetFillColor(style.FillColor)
		b.pdf.Rectangle(x, y, x+w, y+h, "F", 0, 0)
	}

	// Draw border if specified
	if style.HasBorder {
		b.SetStrokeColor(style.BorderColor)
		b.pdf.SetLineWidth(style.BorderWidth)
		b.pdf.Rectangle(x, y, x+w, y+h, "D", 0, 0)
	}

	// Draw text with padding and alignment
	b.SetTextColor(style.TextColor)
	
	maxWidth := w - (style.Padding * 2)
	lineHeight := style.FontSize * 1.2 // Line spacing
	
	// Wrap text into multiple lines if needed
	lines := b.wrapText(text, maxWidth)
	
	// Draw each line
	textY := y + style.Padding + style.FontSize
	for i, line := range lines {
		// Only draw lines that fit within cell height
		lineY := textY + float64(i)*lineHeight
		if lineY > y+h-style.Padding {
			break // Stop if we exceed cell height
		}
		
		lineWidth := b.MeasureTextWidth(line)
		var textX float64
		switch style.Alignment {
		case AlignCenter:
			textX = x + (w-lineWidth)/2
		case AlignRight:
			textX = x + w - lineWidth - style.Padding
		default: // AlignLeft
			textX = x + style.Padding
		}

		b.pdf.SetX(textX)
		b.pdf.SetY(lineY)
		b.pdf.Text(line)
	}

	// Move to next cell position
	b.pdf.SetX(x + w)

	return nil
}

// wrapText splits text into multiple lines that fit within maxWidth
func (b *Builder) wrapText(text string, maxWidth float64) []string {
	if text == "" {
		return []string{""}
	}
	
	// Check if text fits in one line
	textWidth := b.MeasureTextWidth(text)
	if textWidth <= maxWidth {
		return []string{text}
	}
	
	var lines []string
	words := strings.Fields(text)
	
	if len(words) == 0 {
		return []string{text}
	}
	
	currentLine := ""
	for _, word := range words {
		testLine := currentLine
		if testLine != "" {
			testLine += " "
		}
		testLine += word
		
		testWidth := b.MeasureTextWidth(testLine)
		if testWidth <= maxWidth {
			currentLine = testLine
		} else {
			// Current line is full, start a new line
			if currentLine != "" {
				lines = append(lines, currentLine)
			}
			// Check if single word is too long
			wordWidth := b.MeasureTextWidth(word)
			if wordWidth > maxWidth {
				// Break word into chunks
				currentLine = b.breakLongWord(word, maxWidth, &lines)
			} else {
				currentLine = word
			}
		}
	}
	
	// Add remaining text
	if currentLine != "" {
		lines = append(lines, currentLine)
	}
	
	// Limit to max 3 lines to prevent cell overflow
	if len(lines) > 3 {
		lines = lines[:3]
		if len(lines[2]) > 3 {
			lines[2] = lines[2][:len(lines[2])-3] + "..."
		}
	}
	
	return lines
}

// breakLongWord breaks a long word that doesn't fit in one line
func (b *Builder) breakLongWord(word string, maxWidth float64, lines *[]string) string {
	result := ""
	for _, char := range word {
		testStr := result + string(char)
		if b.MeasureTextWidth(testStr) > maxWidth {
			*lines = append(*lines, result)
			result = string(char)
		} else {
			result = testStr
		}
	}
	return result
}

// truncateText truncates text to fit within maxWidth (used for single-line cells)
func (b *Builder) truncateText(text string, maxWidth float64) string {
	if !b.fontLoaded {
		// Rough estimate: 6 points per character
		maxChars := int(maxWidth / 6)
		if len(text) > maxChars && maxChars > 3 {
			return text[:maxChars-3] + "..."
		}
		return text
	}

	width, _ := b.pdf.MeasureTextWidth(text)
	if width <= maxWidth {
		return text
	}

	// Binary search for the right length
	for len(text) > 3 {
		text = text[:len(text)-1]
		width, _ = b.pdf.MeasureTextWidth(text + "...")
		if width <= maxWidth {
			return text + "..."
		}
	}

	return text
}

// MeasureTextWidth measures the width of text
func (b *Builder) MeasureTextWidth(text string) float64 {
	if !b.fontLoaded {
		return float64(len(text)) * 6 // Rough estimate
	}
	width, _ := b.pdf.MeasureTextWidth(text)
	return width
}

// NewLine moves to a new line
func (b *Builder) NewLine(height float64) {
	b.currentY += height
	b.pdf.SetX(b.options.Margin)
	b.pdf.SetY(b.currentY)
}

// NewLineAt moves to a new line and sets X to startX
func (b *Builder) NewLineAt(height float64, startX float64) {
	b.currentY += height
	b.pdf.SetX(startX)
	b.pdf.SetY(b.currentY)
}

// NeedsNewPage checks if we need a new page for the given height
func (b *Builder) NeedsNewPage(height float64) bool {
	pageHeight := b.options.PageSize.Height
	if b.options.Orientation == Landscape {
		pageHeight = b.options.PageSize.Width
	}
	return b.currentY+height > pageHeight-b.options.Margin
}

// DrawTable draws a complete table from data
func (b *Builder) DrawTable(headers []string, rows [][]string, colWidths []float64) error {
	style := DefaultStyle()
	headerStyle := HeaderStyle()

	// Apply custom styles if set
	if b.options.HeaderColor != "" {
		headerStyle.FillColor = ParseHexColor(b.options.HeaderColor)
	}
	if b.options.BorderColor != "" {
		c := ParseHexColor(b.options.BorderColor)
		style.BorderColor = c
		headerStyle.BorderColor = c
	}
	style.HasBorder = b.options.ShowGridLines
	headerStyle.HasBorder = b.options.ShowGridLines

	// Row height will be dynamic per row
	baseLineHeight := style.FontSize * 1.2

	// Calculate total table width for centering
	tableWidth := 0.0
	for _, w := range colWidths {
		tableWidth += w
	}
	
	startX := b.options.Margin
	contentWidth := b.options.ContentWidth()
	if tableWidth < contentWidth {
		startX = b.options.Margin + (contentWidth-tableWidth)/2
	}

	// Draw headers
	if len(headers) > 0 && b.options.HeaderRow {
		b.SetFont(headerStyle.FontFamily, headerStyle.FontStyle, headerStyle.FontSize)
		b.pdf.SetX(startX)

		// Calculate header height once
		headerHeight := (baseLineHeight) + (headerStyle.Padding * 2) + 4

		for i, header := range headers {
			if i < len(colWidths) {
				if err := b.Cell(colWidths[i], headerHeight, header, headerStyle); err != nil {
					return err
				}
			}
		}
		b.NewLineAt(headerHeight, startX)
	}


	// Draw data rows
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	totalRows := len(rows)
	lastProgress := -1
	
	for rowIdx, row := range rows {
		// Report progress
		if b.onProgress != nil {
			percent := int(float64(rowIdx) * 100 / float64(totalRows))
			if percent != lastProgress && percent%5 == 0 { // Report every 5%
				b.onProgress(percent)
				lastProgress = percent
			}
		}



		rowStyle := style // Use base style with custom border color
		if rowIdx%2 == 1 {
			if b.options.RowColor != "" {
				rowStyle.FillColor = ParseHexColor(b.options.RowColor)
			} else {
				rowStyle.FillColor = ColorLightGray
			}
			rowStyle.HasBackground = true
		}
		
		// Calculate max lines for this row
		maxLines := 1
		for i, cell := range row {
			if i < len(colWidths) {
				maxWidth := colWidths[i] - (style.Padding * 2)
				lines := b.wrapText(cell, maxWidth)
				if len(lines) > maxLines {
					maxLines = len(lines)
				}
			}
		}
		
		// Calculate dynamic row height
		currentRowHeight := (baseLineHeight * float64(maxLines)) + (style.Padding * 2) + 4

		// Check new page again with dynamic height
		if b.NeedsNewPage(currentRowHeight) {
			b.AddPage()
			// Redraw headers... (omitted full repeat for brevity, using simplified check)
			// Note: The previous logic inside loop handles basic pagination but 
			// checking here prevents splitting a large row.
			// Re-draw headers logic similar to above...
			if b.options.HeaderRow && len(headers) > 0 {
				b.SetFont(headerStyle.FontFamily, headerStyle.FontStyle, headerStyle.FontSize)
				b.pdf.SetX(startX)
				headerHeight := (baseLineHeight) + (headerStyle.Padding * 2) + 4
				for i, header := range headers {
					if i < len(colWidths) {
						b.Cell(colWidths[i], headerHeight, header, headerStyle)
					}
				}
				b.NewLineAt(headerHeight, startX)
				b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
			}
		}
		
		b.pdf.SetX(startX)

		for i, cell := range row {
			if i < len(colWidths) {
				// Detect alignment based on content (simple heuristic)
				cellStyle := rowStyle
				if isNumeric(cell) {
					cellStyle.Alignment = AlignRight
				}
				
				// Use the calculated row height so cells are uniform
				if err := b.Cell(colWidths[i], currentRowHeight, cell, cellStyle); err != nil {
					return err
				}
			}
		}
		b.NewLineAt(currentRowHeight, startX)
	}

	return nil
}

// AddText adds a text paragraph
func (b *Builder) AddText(text string, style Style) error {
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	b.SetTextColor(style.TextColor)
	b.pdf.SetX(b.options.Margin)
	b.pdf.SetY(b.currentY)
	b.pdf.Text(text)
	b.NewLine(style.FontSize * style.LineHeight)
	return nil
}

// AddImage adds an image from file
func (b *Builder) AddImage(imagePath string, x, y, w, h float64) error {
	return b.pdf.Image(imagePath, x, y, &gopdf.Rect{W: w, H: h})
}

// Save writes the PDF to the specified path
func (b *Builder) Save(outputPath string) error {
	// Ensure output directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	
	// Fill in total page count
	// Fill in total page count
	// IMPORTANT: Set font to match the footer style so the numbers align correctly
	// The footer uses default font, size 8, Gray color
	b.pdf.SetFont("default", "", 8)
	b.pdf.SetTextColor(128, 128, 128) // ColorGray approx
	
	b.pdf.FillInPlaceHoldText("total", fmt.Sprintf("%d", b.pageNum), gopdf.Left)
	
	return b.pdf.WritePdf(outputPath)
}

// isNumeric checks if a string represents a number
func isNumeric(s string) bool {
	s = strings.TrimSpace(s)
	if s == "" {
		return false
	}
	// Simple check for digits, decimal point, and signs
	hasDigit := false
	for _, r := range s {
		if r >= '0' && r <= '9' {
			hasDigit = true
			continue
		}
		if r == '.' || r == '-' || r == '+' || r == ',' {
			continue
		}
		return false
	}
	return hasDigit
}

// GetPdf returns the underlying GoPdf instance for advanced operations
func (b *Builder) GetPdf() *gopdf.GoPdf {
	return b.pdf
}
