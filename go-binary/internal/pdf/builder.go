package pdf

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/signintech/gopdf"
)

// Builder provides a fluent interface for creating PDF documents
type Builder struct {
	pdf       *gopdf.GoPdf
	options   Options
	currentY  float64
	pageNum   int
	fontLoaded bool
	
	onProgress func(int)
}

// SetProgressCallback sets the callback for progress reporting
func (b *Builder) SetProgressCallback(callback func(int)) {
	b.onProgress = callback
}

// NewBuilder creates a new PDF builder with the given options
func NewBuilder(opts Options) (*Builder, error) {
	pdf := &gopdf.GoPdf{}
	pdf.Start(gopdf.Config{PageSize: *opts.GetPageRect()})

	b := &Builder{
		pdf:      pdf,
		options:  opts,
		currentY: opts.Margin,
		pageNum:  0,
	}

	// Load default font
	if err := b.loadFont(); err != nil {
		return nil, err
	}

	return b, nil
}

// loadFont loads the specified font or falls back to built-in
func (b *Builder) loadFont() error {
	// 1. Try custom font if specified
	if b.options.CustomFontPath != "" {
		if _, err := os.Stat(b.options.CustomFontPath); err == nil {
			if err := b.pdf.AddTTFFont("default", b.options.CustomFontPath); err == nil {
				b.fontLoaded = true
				return b.pdf.SetFont("default", "", b.options.FontSize)
			}
		}
	}

	// 2. Try to use system fonts first
	fontPaths := []string{
		"/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
		"/usr/share/fonts/TTF/DejaVuSans.ttf",
		"/System/Library/Fonts/Helvetica.ttc",
		"C:\\Windows\\Fonts\\arial.ttf",
	}

	for _, fontPath := range fontPaths {
		if _, err := os.Stat(fontPath); err == nil {
			if err := b.pdf.AddTTFFont("default", fontPath); err == nil {
				b.fontLoaded = true
				return b.pdf.SetFont("default", "", b.options.FontSize)
			}
		}
	}

	// 3. Fall back to built-in font (limited Unicode support)
	return b.embedMinimalFont()
}

// embedMinimalFont embeds a minimal font for basic operation
func (b *Builder) embedMinimalFont() error {
	// Use the TTF font embedded in the binary or from a known location
	// For now, we'll try common locations
	homeDir, _ := os.UserHomeDir()
	additionalPaths := []string{
		filepath.Join(homeDir, ".fonts", "DejaVuSans.ttf"),
		"/usr/local/share/fonts/truetype/dejavu/DejaVuSans.ttf",
	}

	for _, fontPath := range additionalPaths {
		if _, err := os.Stat(fontPath); err == nil {
			if err := b.pdf.AddTTFFont("default", fontPath); err == nil {
				b.fontLoaded = true
				return b.pdf.SetFont("default", "", b.options.FontSize)
			}
		}
	}

	return nil // Proceed without font, will use basic rendering
}

// AddPage adds a new page to the document
func (b *Builder) AddPage() {
	b.pdf.AddPage()
	b.currentY = b.options.Margin
	b.pageNum++
	
	// Draw watermark first (behind content)
	b.drawWatermark()
	
	// Draw global header and footer
	b.drawHeader()
	b.drawFooter()
	
	// Reset Y to below header (add extra space if header text exists)
	if b.options.HeaderText != "" {
		b.currentY = b.options.Margin + 25
	} else {
		b.currentY = b.options.Margin
	}
}

func (b *Builder) drawHeader() {
	// Only draw header if custom text is provided
	if b.options.HeaderText == "" {
		return
	}
	
	style := DefaultStyle()
	style.FontSize = 10
	style.TextColor = ColorBlack
	
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	b.SetTextColor(style.TextColor)
	
	// Set Y position at top margin
	b.pdf.SetY(b.options.Margin - 5)
	
	// Draw centered header text
	b.drawTextWithPlaceholders(b.options.HeaderText, AlignCenter)
}

func (b *Builder) drawFooter() {
	pageHeight := b.options.PageSize.Height
	if b.options.Orientation == Landscape {
		pageHeight = b.options.PageSize.Width
	}
	
	style := DefaultStyle()
	style.FontSize = 8
	style.TextColor = ColorGray
	
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	b.SetTextColor(style.TextColor)
	
	footerY := pageHeight - b.options.Margin + 5

	// Simplified Footer:
	// Left: Custom Text (or default)
	// Right: Page Info (Fixed)

	// Left Section
	text := b.options.FooterText
	if text == "" {
		text = "Generated by GoPdfConverter" // Default
	}
	
	b.pdf.SetX(b.options.Margin)
	b.pdf.SetY(footerY)
	b.drawTextWithPlaceholders(text, AlignLeft)

	// Right Section: Page Info (Fixed)
	// "Page X of Y"
	pageInfo := "Page {{page}} of {{total}}"
	b.pdf.SetY(footerY)
	b.drawTextWithPlaceholders(pageInfo, AlignRight)
}

func (b *Builder) drawTextWithPlaceholders(text string, align int) {
	// Paging placeholders
	text = strings.ReplaceAll(text, "{{page}}", fmt.Sprintf("%d", b.pageNum))
	
	// Total pages is tricky because we don't know it yet.
	// For "Page X of Y", we usually use a template approach or write it at the end.
	// Gopdf has a specific way to handle total pages using FillInPlaceHoldText
	
	hasTotal := strings.Contains(text, "{{total}}")
	b.drawAligned(text, align, hasTotal)
}

func (b *Builder) drawAligned(text string, align int, hasPlaceholder bool) {
	pageWidth := b.options.PageSize.Width
	if b.options.Orientation == Landscape {
		pageWidth = b.options.PageSize.Height
	}
	contentWidth := pageWidth - (b.options.Margin * 2)

	// Measure text width
	// Note: If hasPlaceholder, we might need to estimate
	textWidth := b.MeasureTextWidth(text)
	if hasPlaceholder {
		textWidth += 20 // Estimate for number
	}

	var x float64
	switch align {
	case AlignLeft:
		x = b.options.Margin
	case AlignCenter:
		x = b.options.Margin + (contentWidth-textWidth)/2
	case AlignRight:
		x = b.options.Margin + contentWidth - textWidth
	}

	// Use explicit Text drawing to ensure baseline alignment matches
	// PlaceHolderText behavior and avoids Cell vertical centering issues
	b.pdf.SetX(x)
	
	if hasPlaceholder {
		parts := strings.Split(text, "{{total}}")
		
		// 1. Draw Prefix (e.g. "Page 1 of ")
		if len(parts) > 0 && parts[0] != "" {
			b.pdf.Text(parts[0])
			// Advance X manually
			w, _ := b.pdf.MeasureTextWidth(parts[0])
			x += w
			b.pdf.SetX(x)
		}
		
		// 2. Draw Placeholder
		currentY := b.pdf.GetY()
		b.pdf.PlaceHolderText("total", 20)
		
		x += 20 // Advance X for placeholder width
		b.pdf.SetX(x)
		
		// Restore Y just in case PlaceHolderText moved it (it shouldn't)
		b.pdf.SetY(currentY)
		
		// 3. Draw Suffix
		if len(parts) > 1 && parts[1] != "" {
			b.pdf.Text(parts[1])
		}
	} else {
		b.pdf.Text(text)
	}
}

// SetFont sets the current font
func (b *Builder) SetFont(family string, style string, size float64) error {
	if !b.fontLoaded {
		return nil
	}
	return b.pdf.SetFont("default", style, size)
}

// SetTextColor sets the text color
func (b *Builder) SetTextColor(c Color) {
	b.pdf.SetTextColor(c.R, c.G, c.B)
}

// SetFillColor sets the fill color
func (b *Builder) SetFillColor(c Color) {
	b.pdf.SetFillColor(c.R, c.G, c.B)
}

// SetStrokeColor sets the stroke/border color
func (b *Builder) SetStrokeColor(c Color) {
	b.pdf.SetStrokeColor(c.R, c.G, c.B)
}

// GetX returns current X position
func (b *Builder) GetX() float64 {
	return b.pdf.GetX()
}

// GetY returns current Y position
func (b *Builder) GetY() float64 {
	return b.currentY
}

// SetXY sets the current position
func (b *Builder) SetXY(x, y float64) {
	b.pdf.SetX(x)
	b.pdf.SetY(y)
	b.currentY = y
}

// drawWatermark draws a watermark on the current page
func (b *Builder) drawWatermark() {
	if b.options.WatermarkText == "" && b.options.WatermarkImage == "" {
		return
	}

	// Save current state
	// b.pdf.SetAlpha(b.options.WatermarkAlpha, "Normal")
	// defer b.pdf.SetAlpha(1.0, "Normal")

	pageW := b.options.PageSize.Width
	pageH := b.options.PageSize.Height
	if b.options.Orientation == Landscape {
		pageW, pageH = pageH, pageW
	}

	// Draw Image Watermark
	if b.options.WatermarkImage != "" {
		if _, err := os.Stat(b.options.WatermarkImage); err == nil {
			// Center image
			imgW := 200.0 // Default width
			imgH := 200.0 // Default height
			x := (pageW - imgW) / 2
			y := (pageH - imgH) / 2
			b.pdf.Image(b.options.WatermarkImage, x, y, &gopdf.Rect{W: imgW, H: imgH})
		}
	}

	// Draw Text Watermark
	if b.options.WatermarkText != "" {
		b.pdf.SetTextColor(200, 200, 200) // Light gray
		
		// Calculate font size based on page width
		fontSize := pageW / 10
		b.pdf.SetFont("default", "", fontSize)
		
		textWidth := b.MeasureTextWidth(b.options.WatermarkText)
		x := (pageW - textWidth) / 2
		y := pageH / 2

		// Rotate text 45 degrees
		b.pdf.Rotate(45, x+textWidth/2, y)
		b.pdf.SetX(x)
		b.pdf.SetY(y)
		b.pdf.Text(b.options.WatermarkText)
		b.pdf.RotateReset()
	}
}

// Cell draws a cell with text, supporting text wrapping for long content
func (b *Builder) Cell(w, h float64, text string, style Style) error {
	x := b.pdf.GetX()
	y := b.currentY

	// Draw background if specified
	if style.HasBackground {
		b.SetFillColor(style.FillColor)
		b.pdf.Rectangle(x, y, x+w, y+h, "F", 0, 0)
	}

	// Draw border if specified
	if style.HasBorder {
		b.SetStrokeColor(style.BorderColor)
		b.pdf.SetLineWidth(style.BorderWidth)
		b.pdf.Rectangle(x, y, x+w, y+h, "D", 0, 0)
	}

	// Draw text with padding and alignment
	b.SetTextColor(style.TextColor)
	
	maxWidth := w - (style.Padding * 2)
	lineHeight := style.FontSize * 1.2 // Line spacing
	
	// Wrap text into multiple lines if needed
	lines := b.wrapText(text, maxWidth)
	
	// Draw each line
	textY := y + style.Padding + style.FontSize
	for i, line := range lines {
		// Only draw lines that fit within cell height
		lineY := textY + float64(i)*lineHeight
		if lineY > y+h-style.Padding {
			break // Stop if we exceed cell height
		}
		
		lineWidth := b.MeasureTextWidth(line)
		var textX float64
		switch style.Alignment {
		case AlignCenter:
			textX = x + (w-lineWidth)/2
		case AlignRight:
			textX = x + w - lineWidth - style.Padding
		default: // AlignLeft
			textX = x + style.Padding
		}

		b.pdf.SetX(textX)
		b.pdf.SetY(lineY)
		b.pdf.Text(line)
	}

	// Move to next cell position
	b.pdf.SetX(x + w)

	return nil
}

// wrapText splits text into multiple lines that fit within maxWidth
// Optimized for memory efficiency with large text
func (b *Builder) wrapText(text string, maxWidth float64) []string {
	if text == "" {
		return []string{""}
	}
	
	// Quick check if text fits in one line
	textWidth := b.MeasureTextWidth(text)
	if textWidth <= maxWidth {
		return []string{text}
	}
	
	// Pre-allocate with estimated capacity
	estimatedLines := int(textWidth/maxWidth) + 1
	lines := make([]string, 0, estimatedLines)
	
	words := strings.Fields(text)
	if len(words) == 0 {
		return []string{text}
	}
	
	// Use strings.Builder for efficient string concatenation
	var currentLine strings.Builder
	currentLine.Grow(128) // Pre-allocate buffer
	
	for _, word := range words {
		testLen := currentLine.Len()
		if testLen > 0 {
			testLen++ // for space
		}
		testLen += len(word)
		
		// Build test string only if needed
		var testLine string
		if currentLine.Len() > 0 {
			testLine = currentLine.String() + " " + word
		} else {
			testLine = word
		}
		
		testWidth := b.MeasureTextWidth(testLine)
		if testWidth <= maxWidth {
			if currentLine.Len() > 0 {
				currentLine.WriteString(" ")
			}
			currentLine.WriteString(word)
		} else {
			// Current line is full, start a new line
			if currentLine.Len() > 0 {
				lines = append(lines, currentLine.String())
				currentLine.Reset()
			}
			// Check if single word is too long
			wordWidth := b.MeasureTextWidth(word)
			if wordWidth > maxWidth {
				// Break word into chunks
				remainder := b.breakLongWordOptimized(word, maxWidth, &lines)
				currentLine.WriteString(remainder)
			} else {
				currentLine.WriteString(word)
			}
		}
	}
	
	// Add remaining text
	if currentLine.Len() > 0 {
		lines = append(lines, currentLine.String())
	}
	
	return lines
}

// breakLongWordOptimized breaks a long word that doesn't fit in one line (memory optimized)
func (b *Builder) breakLongWordOptimized(word string, maxWidth float64, lines *[]string) string {
	var current strings.Builder
	current.Grow(len(word))
	
	for _, char := range word {
		testStr := current.String() + string(char)
		if b.MeasureTextWidth(testStr) > maxWidth {
			if current.Len() > 0 {
				*lines = append(*lines, current.String())
				current.Reset()
			}
		}
		current.WriteRune(char)
	}
	return current.String()
}

// truncateText truncates text to fit within maxWidth (used for single-line cells)
func (b *Builder) truncateText(text string, maxWidth float64) string {
	if !b.fontLoaded {
		// Rough estimate: 6 points per character
		maxChars := int(maxWidth / 6)
		if len(text) > maxChars && maxChars > 3 {
			return text[:maxChars-3] + "..."
		}
		return text
	}

	width, _ := b.pdf.MeasureTextWidth(text)
	if width <= maxWidth {
		return text
	}

	// Binary search for the right length
	for len(text) > 3 {
		text = text[:len(text)-1]
		width, _ = b.pdf.MeasureTextWidth(text + "...")
		if width <= maxWidth {
			return text + "..."
		}
	}

	return text
}

// MeasureTextWidth measures the width of text
func (b *Builder) MeasureTextWidth(text string) float64 {
	if !b.fontLoaded {
		return float64(len(text)) * 6 // Rough estimate
	}
	width, _ := b.pdf.MeasureTextWidth(text)
	return width
}

// NewLine moves to a new line
func (b *Builder) NewLine(height float64) {
	b.currentY += height
	b.pdf.SetX(b.options.Margin)
	b.pdf.SetY(b.currentY)
}

// NewLineAt moves to a new line and sets X to startX
func (b *Builder) NewLineAt(height float64, startX float64) {
	b.currentY += height
	b.pdf.SetX(startX)
	b.pdf.SetY(b.currentY)
}

// NeedsNewPage checks if we need a new page for the given height
func (b *Builder) NeedsNewPage(height float64) bool {
	pageHeight := b.options.PageSize.Height
	if b.options.Orientation == Landscape {
		pageHeight = b.options.PageSize.Width
	}
	return b.currentY+height > pageHeight-b.options.Margin
}

// DrawTable draws a complete table from data (for smaller datasets)
// For large datasets, use DrawTableStreaming instead
func (b *Builder) DrawTable(headers []string, rows [][]string, colWidths []float64) error {
	style := DefaultStyle()
	headerStyle := HeaderStyle()

	// Apply custom cell padding
	if b.options.CellPadding > 0 {
		style.Padding = b.options.CellPadding
		headerStyle.Padding = b.options.CellPadding
	}

	// Apply custom styles if set
	if b.options.HeaderColor != "" {
		headerStyle.FillColor = ParseHexColor(b.options.HeaderColor)
	}
	if b.options.HeaderTextColor != "" {
		headerStyle.TextColor = ParseHexColor(b.options.HeaderTextColor)
	}
	if b.options.RowTextColor != "" {
		style.TextColor = ParseHexColor(b.options.RowTextColor)
	}
	if b.options.BorderColor != "" {
		c := ParseHexColor(b.options.BorderColor)
		style.BorderColor = c
		headerStyle.BorderColor = c
	}
	style.HasBorder = b.options.ShowGridLines
	headerStyle.HasBorder = b.options.ShowGridLines

	// Apply header font settings
	if b.options.HeaderFontSize > 0 {
		headerStyle.FontSize = b.options.HeaderFontSize
	}
	if b.options.HeaderFontBold {
		headerStyle.FontStyle = "B"
	} else {
		headerStyle.FontStyle = ""
	}

	// Row height will be dynamic per row
	baseLineHeight := style.FontSize * 1.2

	// Calculate total table width for centering
	tableWidth := 0.0
	for _, w := range colWidths {
		tableWidth += w
	}
	
	startX := b.options.Margin
	contentWidth := b.options.ContentWidth()
	if tableWidth < contentWidth {
		startX = b.options.Margin + (contentWidth-tableWidth)/2
	}

	// Pre-calculate header height
	var headerHeight float64
	if b.options.HeaderHeight > 0 {
		headerHeight = b.options.HeaderHeight
	} else {
		headerHeight = baseLineHeight + (headerStyle.Padding * 2) + 4
	}

	// Draw headers
	if len(headers) > 0 && b.options.HeaderRow {
		b.SetFont(headerStyle.FontFamily, headerStyle.FontStyle, headerStyle.FontSize)
		b.pdf.SetX(startX)

		for i, header := range headers {
			if i < len(colWidths) {
				if err := b.Cell(colWidths[i], headerHeight, header, headerStyle); err != nil {
					return err
				}
			}
		}
		b.NewLineAt(headerHeight, startX)
	}

	// Draw data rows
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	totalRows := len(rows)
	lastProgress := -1
	
	// Pre-calculate max widths for text wrapping
	maxWidths := make([]float64, len(colWidths))
	for i, w := range colWidths {
		maxWidths[i] = w - (style.Padding * 2)
	}
	
	for rowIdx, row := range rows {
		// Report progress every 5%
		if b.onProgress != nil {
			percent := int(float64(rowIdx) * 100 / float64(totalRows))
			if percent != lastProgress && percent%5 == 0 {
				b.onProgress(percent)
				lastProgress = percent
			}
		}

		// Reuse rowStyle, only modify when needed
		rowStyle := style
		if rowIdx%2 == 1 {
			if b.options.RowColor != "" {
				rowStyle.FillColor = ParseHexColor(b.options.RowColor)
			} else {
				rowStyle.FillColor = ColorLightGray
			}
			rowStyle.HasBackground = true
		}
		
		// Calculate row height
		var currentRowHeight float64
		if b.options.RowHeight > 0 {
			currentRowHeight = b.options.RowHeight
		} else {
			maxLines := 1
			for i, cell := range row {
				if i < len(maxWidths) {
					lines := b.wrapText(cell, maxWidths[i])
					if len(lines) > maxLines {
						maxLines = len(lines)
					}
				}
			}
			currentRowHeight = (baseLineHeight * float64(maxLines)) + (style.Padding * 2) + 4
		}

		// Check for new page
		if b.NeedsNewPage(currentRowHeight) {
			b.AddPage()
			// Re-draw headers on new page
			if b.options.HeaderRow && len(headers) > 0 {
				b.SetFont(headerStyle.FontFamily, headerStyle.FontStyle, headerStyle.FontSize)
				b.pdf.SetX(startX)
				for i, header := range headers {
					if i < len(colWidths) {
						b.Cell(colWidths[i], headerHeight, header, headerStyle)
					}
				}
				b.NewLineAt(headerHeight, startX)
				b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
			}
		}
		
		b.pdf.SetX(startX)

		for i, cell := range row {
			if i < len(colWidths) {
				cellStyle := rowStyle
				if isNumeric(cell) {
					cellStyle.Alignment = AlignRight
				}
				if err := b.Cell(colWidths[i], currentRowHeight, cell, cellStyle); err != nil {
					return err
				}
			}
		}
		b.NewLineAt(currentRowHeight, startX)
	}

	return nil
}

// AddText adds a text paragraph
func (b *Builder) AddText(text string, style Style) error {
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	b.SetTextColor(style.TextColor)
	b.pdf.SetX(b.options.Margin)
	b.pdf.SetY(b.currentY)
	b.pdf.Text(text)
	b.NewLine(style.FontSize * style.LineHeight)
	return nil
}

// AddImage adds an image from file
func (b *Builder) AddImage(imagePath string, x, y, w, h float64) error {
	return b.pdf.Image(imagePath, x, y, &gopdf.Rect{W: w, H: h})
}

// Save writes the PDF to the specified path
func (b *Builder) Save(outputPath string) error {
	// Ensure output directory exists
	dir := filepath.Dir(outputPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	
	// Fill in total page count
	// Fill in total page count
	// IMPORTANT: Set font to match the footer style so the numbers align correctly
	// The footer uses default font, size 8, Gray color
	b.pdf.SetFont("default", "", 8)
	b.pdf.SetTextColor(128, 128, 128) // ColorGray approx
	
	b.pdf.FillInPlaceHoldText("total", fmt.Sprintf("%d", b.pageNum), gopdf.Left)
	
	return b.pdf.WritePdf(outputPath)
}

// isNumeric checks if a string represents a number
func isNumeric(s string) bool {
	s = strings.TrimSpace(s)
	if s == "" {
		return false
	}
	// Simple check for digits, decimal point, and signs
	hasDigit := false
	for _, r := range s {
		if r >= '0' && r <= '9' {
			hasDigit = true
			continue
		}
		if r == '.' || r == '-' || r == '+' || r == ',' {
			continue
		}
		return false
	}
	return hasDigit
}

// GetPdf returns the underlying GoPdf instance for advanced operations
func (b *Builder) GetPdf() *gopdf.GoPdf {
	return b.pdf
}

// RowIterator interface for streaming row data
type RowIterator interface {
	Next() bool
	Columns() ([]string, error)
}

// DrawTableStreaming draws a table from streaming row data (memory efficient)
func (b *Builder) DrawTableStreaming(headers []string, rows RowIterator, colWidths []float64, hasHeaderRow bool) error {
	style := DefaultStyle()
	headerStyle := HeaderStyle()

	// Apply custom cell padding
	if b.options.CellPadding > 0 {
		style.Padding = b.options.CellPadding
		headerStyle.Padding = b.options.CellPadding
	}

	// Apply custom styles
	if b.options.HeaderColor != "" {
		headerStyle.FillColor = ParseHexColor(b.options.HeaderColor)
	}
	if b.options.HeaderTextColor != "" {
		headerStyle.TextColor = ParseHexColor(b.options.HeaderTextColor)
	}
	if b.options.RowTextColor != "" {
		style.TextColor = ParseHexColor(b.options.RowTextColor)
	}
	if b.options.BorderColor != "" {
		c := ParseHexColor(b.options.BorderColor)
		style.BorderColor = c
		headerStyle.BorderColor = c
	}
	style.HasBorder = b.options.ShowGridLines
	headerStyle.HasBorder = b.options.ShowGridLines

	if b.options.HeaderFontSize > 0 {
		headerStyle.FontSize = b.options.HeaderFontSize
	}
	if b.options.HeaderFontBold {
		headerStyle.FontStyle = "B"
	} else {
		headerStyle.FontStyle = ""
	}

	baseLineHeight := style.FontSize * 1.2

	// Calculate table positioning
	tableWidth := 0.0
	for _, w := range colWidths {
		tableWidth += w
	}
	
	startX := b.options.Margin
	contentWidth := b.options.ContentWidth()
	if tableWidth < contentWidth {
		startX = b.options.Margin + (contentWidth-tableWidth)/2
	}

	// Calculate header height
	var headerHeight float64
	if b.options.HeaderHeight > 0 {
		headerHeight = b.options.HeaderHeight
	} else {
		headerHeight = baseLineHeight + (headerStyle.Padding * 2) + 4
	}

	// Draw headers if provided
	if len(headers) > 0 && hasHeaderRow {
		b.SetFont(headerStyle.FontFamily, headerStyle.FontStyle, headerStyle.FontSize)
		b.pdf.SetX(startX)
		for i, header := range headers {
			if i < len(colWidths) {
				b.Cell(colWidths[i], headerHeight, header, headerStyle)
			}
		}
		b.NewLineAt(headerHeight, startX)
	}

	// Stream rows
	b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
	rowIdx := 0
	skipFirst := hasHeaderRow // Skip first row if it's the header

	for rows.Next() {
		row, err := rows.Columns()
		if err != nil {
			continue
		}

		// Skip header row in data
		if skipFirst {
			skipFirst = false
			continue
		}

		// Progress reporting every 1000 rows
		if b.onProgress != nil && rowIdx%1000 == 0 {
			b.onProgress(rowIdx / 100) // Approximate progress
		}

		rowStyle := style
		if rowIdx%2 == 1 {
			if b.options.RowColor != "" {
				rowStyle.FillColor = ParseHexColor(b.options.RowColor)
			} else {
				rowStyle.FillColor = ColorLightGray
			}
			rowStyle.HasBackground = true
		}

		// Calculate row height
		var currentRowHeight float64
		if b.options.RowHeight > 0 {
			currentRowHeight = b.options.RowHeight
		} else {
			maxLines := 1
			for i, cell := range row {
				if i < len(colWidths) {
					maxWidth := colWidths[i] - (style.Padding * 2)
					lines := b.wrapText(cell, maxWidth)
					if len(lines) > maxLines {
						maxLines = len(lines)
					}
				}
			}
			currentRowHeight = (baseLineHeight * float64(maxLines)) + (style.Padding * 2) + 4
		}

		// Check for new page
		if b.NeedsNewPage(currentRowHeight) {
			b.AddPage()
			// Redraw headers
			if len(headers) > 0 && hasHeaderRow {
				b.SetFont(headerStyle.FontFamily, headerStyle.FontStyle, headerStyle.FontSize)
				b.pdf.SetX(startX)
				for i, header := range headers {
					if i < len(colWidths) {
						b.Cell(colWidths[i], headerHeight, header, headerStyle)
					}
				}
				b.NewLineAt(headerHeight, startX)
				b.SetFont(style.FontFamily, style.FontStyle, style.FontSize)
			}
		}

		b.pdf.SetX(startX)
		for i, cell := range row {
			if i < len(colWidths) {
				cellStyle := rowStyle
				if isNumeric(cell) {
					cellStyle.Alignment = AlignRight
				}
				b.Cell(colWidths[i], currentRowHeight, cell, cellStyle)
			}
		}
		b.NewLineAt(currentRowHeight, startX)
		rowIdx++
	}

	return nil
}
